---
layout: post
mathjax: true
description: ""
category: "算法"
tags: ["leetcode", "算法", "动态规划"]
---
{% include JB/setup %}

[1235.规划兼职工作](https://leetcode.cn/problems/maximum-profit-in-job-scheduling/description/?envType=daily-question&envId=2024-05-04)

带权重的区间选择。按右端点排序。

归纳假设：已知前n个区间最右端点为j时的最大权重和，其中j<=e(e为n区间的end)
推导：如果不选择第n+1个区间，最大权重和不变。选择第n+1个区间，最大权重和=dp[k] + w(end[k]<start[n+1])。只有当dp[k]+w 大于之前的权重和时，才需要加入（类似于单调栈）；同时在右端点重复时需要移除之前的元素。
```
class Solution:
    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:
        a = sorted([(s,e,p) for s,e,p in zip(startTime,endTime,profit)], key=lambda x:x[1])
        dp = [(0,0)]
        for s,e,p in a:
            i = bisect_right(dp,s,key=lambda x:x[0]) - 1
            cur = dp[i][1] + p
            if dp[-1][1] < cur:
                if dp[-1][0] == e:
                    dp.pop()
                dp.append((e,cur))
        return dp[-1][1]
```

归纳假设：已知前n个区间的最大权重和。
```
class Solution:
    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:
        n = len(startTime)
        a = sorted([(s,e,p) for s,e,p in zip(startTime,endTime,profit)], key=lambda x:x[1])
        dp = [0] * (n+1)
        for i,(s,e,p) in enumerate(a):
            j = bisect_right(a,s,key=lambda x:x[1],hi=i) - 1
            dp[i+1] = max(dp[i], dp[j+1] + p)
        return dp[-1]
```

> 在写二分题目时，经常会遇到形如「在有序数组中查询大于某个数的最小数」这类问题。[link](https://leetcode.cn/problems/maximum-profit-in-job-scheduling/solutions/1913089/dong-tai-gui-hua-er-fen-cha-zhao-you-hua-zkcg/?envType=daily-question&envId=2024-05-04)

python的bisect只提供了>=(bisect_left)和>(bisect_right)。<=和<可以转换而来。

`<=` bisect_right - 1

`<`  bisect_left - 1