---
layout: post
mathjax: true
description: ""
category: "算法"
tags: ["leetcode","好问题"]
---
{% include JB/setup %}

## [2831. 找出最长等值子数组](https://leetcode.cn/problems/find-the-longest-equal-subarray/description/?envType=daily-question&envId=2024-05-23)

分组+滑动窗口。

## [1673. 找出最具竞争力的子序列](https://leetcode.cn/problems/find-the-most-competitive-subsequence/description/?envType=daily-question&envId=2024-05-24)

<https://leetcode.cn/problems/find-the-most-competitive-subsequence/solutions/508136/ju-yi-fan-san-tan-xin-dan-diao-zhan-wen-ti-by-ekna/?envType=daily-question&envId=2024-05-24>

<https://leetcode.cn/problems/find-the-most-competitive-subsequence/solutions/2788312/gen-zhao-wo-guo-yi-bian-shi-li-2ni-jiu-m-36c4/?envType=daily-question&envId=2024-05-24>

思考过程：假设已经选出x个数，现在需要选第x+1个数。x+1个数应该是nums[x的下标+1：-(k-x-1)]中最小的。这样应该可以用线段树做。
反过来想，需要排除掉len(nums)-k个数，可以用单调栈的思想，只要还剩可以排除的额度，后来加入的数字可以排除掉栈中的数字。

类似：
- [402. 移掉 K 位数字](https://leetcode.cn/problems/remove-k-digits/description/)
剩余额度就是k

- [316. 去除重复字母](https://leetcode.cn/problems/remove-duplicate-letters/description/)
只要>1，就可以排除。同时是否加入也需要考虑，如果已经在st中，就不加入。


  