---
layout: post
mathjax: true
description: ""
category: "算法"
tags: ["leetcode","好问题"]
---
{% include JB/setup %}

## [2831. 找出最长等值子数组](https://leetcode.cn/problems/find-the-longest-equal-subarray/description/?envType=daily-question&envId=2024-05-23)

分组+滑动窗口。

## [1673. 找出最具竞争力的子序列](https://leetcode.cn/problems/find-the-most-competitive-subsequence/description/?envType=daily-question&envId=2024-05-24)

单调栈排除。

<https://leetcode.cn/problems/find-the-most-competitive-subsequence/solutions/508136/ju-yi-fan-san-tan-xin-dan-diao-zhan-wen-ti-by-ekna/?envType=daily-question&envId=2024-05-24>

<https://leetcode.cn/problems/find-the-most-competitive-subsequence/solutions/2788312/gen-zhao-wo-guo-yi-bian-shi-li-2ni-jiu-m-36c4/?envType=daily-question&envId=2024-05-24>

思考过程：假设已经选出x个数，现在需要选第x+1个数。x+1个数应该是nums[x的下标+1：-(k-x-1)]中最小的。这样应该可以用线段树做。
反过来想，需要排除掉len(nums)-k个数，可以用单调栈的思想，只要还剩可以排除的额度，后来加入的数字可以排除掉栈中的数字。

类似：
- [402. 移掉 K 位数字](https://leetcode.cn/problems/remove-k-digits/description/)
剩余额度就是k

- [316. 去除重复字母](https://leetcode.cn/problems/remove-duplicate-letters/description/)
只要>1，就可以排除。同时是否加入也需要考虑，如果已经在st中，就不加入。

- [321. 拼接最大数](https://leetcode.cn/problems/create-maximum-number/description/)
从nums1和nums2中分别取l1,l2个数, l1+l2==k, 求(l1,l2)所有组合中的最大值。
在按顺序比较两个list的时候，可以直接用大于号。在merge的时候使用大于号可以简化代码。
<https://stackoverflow.com/questions/58351944/how-can-i-get-the-source-implement-of-list-gt-func>

```py
class Solution:
    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:
        def f(a, k):
            st = []
            r = len(a)-k
            for x in a:
                while r>0 and st and st[-1] < x:
                    st.pop()
                    r -= 1
                st.append(x)
            return st[:k]
        
        def merge(a1,a2):
            res = []
            a1 = deque(a1)
            a2 = deque(a2)
            while a1 or a2:
                if a1>a2:
                    res.append(a1.popleft())
                else:
                    res.append(a2.popleft())
            return res

        ans = [-1]
        min1 = max(0, k - len(nums2))
        max1 = min(len(nums1), k)
        for l1 in range(min1, max1+1):
            l2 = k-l1
            a1 = f(nums1, l1)
            a2 = f(nums2, l2)
            cur = merge(a1,a2)
            ans = max(ans,cur)
        return ans
```

## [2909. 元素和最小的山形三元组 II](https://leetcode.cn/problems/minimum-sum-of-mountain-triplets-ii/description/)
前后缀分解

## [287. 寻找重复数](https://leetcode.cn/problems/find-the-duplicate-number/description/)
1. 二进制按位求和。设第i位nums和为y，[1..n]的和为x，只有y>x时，target的第i位才是1。

`x.bit_length()`是表示x需要的最少位数。<https://docs.python.org/3/library/stdtypes.html#int.bit_length> 按位循环不需要+1：`range(x.bit_length())`

2. 二分答案。如果len(num<=mid) <= mid ，可以排除掉<=mid, 反之可以排除掉>mid

- [41. 缺失的第一个正数](https://leetcode.cn/problems/first-missing-positive/description/)
原地哈希：如果nums[i] 是负数，说明i+1在nums中。

## [2982. 找出出现至少三次的最长特殊子字符串 II](https://leetcode.cn/problems/find-longest-special-substring-that-occurs-thrice-ii/description/)
先分组循环，然后
- 由于至少三次，，可以分类讨论；讨论时可以用extend[0,0]简化if else
- 当至少k次时，可以二分答案。
求小于等于
```py
while l<r:
    mid = (l+r>>1) + 1
    if not valid(mid):
        r = mid - 1
    else:
        l = mid 
return l
```
也可以求大于，然后-1
```py
r += 1
while l<r:
    mid = l+r>>1
    if not valid(mid):
        r = mid
    else:
        l = mid + 1
return l - 1
```