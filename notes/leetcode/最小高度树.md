

[310. 最小高度树](https://leetcode.cn/problems/minimum-height-trees/description/)

## 拓扑排序

树：没有环的连通图。

直观解法：从外向内剥离叶子节点（只有1个相邻节点的节点），直到最后一层。

```python
class Solution:
    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:
        ind = [0] * n
        g = [[] for _ in range(n)]
        for a,b in edges:
            g[a].append(b)
            g[b].append(a)
            ind[a] += 1
            ind[b] += 1

        q = deque()
        r = n
        for i,x in enumerate(ind):
            if x<=1: 
                q.append(i)
                r -= 1       
        while r != 0:
            for _ in range(len(q)):
                x = q.popleft()
                for y in g[x]:
                    ind[y] -= 1
                    if ind[y] == 1:
                        r -= 1
                        q.append(y)
        return list(q)
```

## 树形DP的做法比较复杂。

错误的尝试：首先求出根为0的高度，然后归纳。但是归纳的过程错误。

```python
class Solution:
    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:
        cnt = defaultdict(list)
        g = [[] for _ in range(n)]
        for a,b in edges:
            g[a].append(b)
            g[b].append(a)
        
        def dfs1(x,fa):
            return 1 + max( [dfs1(y,x) for y in g[x] if y != fa], default=-1)
        h0 = dfs1(0,-1)

        def dfs2(x,fa,h):
            for y in g[x]:
                if y != fa:
                    cur = h
                    # 这里不对
                    if len(g[x])==1: cur-=1 
                    if len(g[y])==1: cur+=1
                    cnt[cur].append(y)
                    dfs2(y,x,cur)
        cnt[h0].append(0)
        dfs2(0,-1,h0)
        return cnt[min(cnt.keys())]
```

