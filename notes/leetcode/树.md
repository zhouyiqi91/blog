
## 定义
树：没有环的连通图

## 题目

### [331\. 验证二叉树的前序序列化](https://leetcode.cn/problems/verify-preorder-serialization-of-a-binary-tree/)

模拟前序遍历，只有下标x等于n-1时才是正确的前序序列。
```py
class Solution:
    def isValidSerialization(self, preorder: str) -> bool:
        a = preorder.split(',')
        n = len(a)
        self.valid = True
        def dfs(x):
            if x >= n:
                self.valid = False
                return n
            if a[x] == '#':
                return x
            left_end = dfs(x+1)
            return dfs(left_end+1)

        end = dfs(0)
        if end != n-1: return False
        return self.valid
```

空节点消耗一个出度，非空节点消耗一个出度，然后提供两个出度。 遍历开始时，出度不能为0，否则无法消耗。

```py
class Solution:
    def isValidSerialization(self, preorder: str) -> bool:
        a = preorder.split(',')
        slot = 1
        for x in a:
            if slot==0: return False
            if x == '#':
                slot -= 1
            else:
                slot += 1
            if slot < 0:
                return False
        return slot==0
```

### [310. 最小高度树](https://leetcode.cn/problems/minimum-height-trees/description/)

拓扑排序

树：没有环的连通图。

直观解法：从外向内剥离叶子节点（只有1个相邻节点的节点），直到最后一层。

```python
class Solution:
    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:
        ind = [0] * n
        g = [[] for _ in range(n)]
        for a,b in edges:
            g[a].append(b)
            g[b].append(a)
            ind[a] += 1
            ind[b] += 1

        q = deque()
        r = n
        for i,x in enumerate(ind):
            if x<=1: 
                q.append(i)
                r -= 1       
        while r != 0:
            for _ in range(len(q)):
                x = q.popleft()
                for y in g[x]:
                    ind[y] -= 1
                    if ind[y] == 1:
                        r -= 1
                        q.append(y)
        return list(q)
```

树形DP的做法比较复杂。

错误的尝试：首先求出根为0的高度，然后归纳。但是归纳的过程错误。

```python
class Solution:
    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:
        cnt = defaultdict(list)
        g = [[] for _ in range(n)]
        for a,b in edges:
            g[a].append(b)
            g[b].append(a)
        
        def dfs1(x,fa):
            return 1 + max( [dfs1(y,x) for y in g[x] if y != fa], default=-1)
        h0 = dfs1(0,-1)

        def dfs2(x,fa,h):
            for y in g[x]:
                if y != fa:
                    cur = h
                    # 这里不对
                    if len(g[x])==1: cur-=1 
                    if len(g[y])==1: cur+=1
                    cnt[cur].append(y)
                    dfs2(y,x,cur)
        cnt[h0].append(0)
        dfs2(0,-1,h0)
        return cnt[min(cnt.keys())]
```

